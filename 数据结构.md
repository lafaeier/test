# 数据结构

---

---

# 前情提要

## 算数

指数，对数，级数，模运算
## 证明方法

## 递归简论

## c++

---

# 算法分析

## 时间复杂度

![](https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006140755.png)

依次为小于等于，大于等于，等于，小于

### 部分公式

$$  
前n项和 s=\frac{n(a_n+a_0)}{2}  
$$

  

$$  
s=\frac{a_1(1-q^{n-1})}{1-q}  
$$

  

一般的，计算复杂度即为计算最内层循环的次数，需要等差和等比的前n项和。

## 空间复杂度

---

# 表，栈和队列

## 抽象数据类型（ADT）

能够实现类似于删除，插入，修改，搜索，比较等操作的数据结构，不同于整数，实数等的数据结构

## 表（List）

### List的数组实现
```cpp
 #include<bits/stdc++.h>  
 using namespace std;  
 class List{  
     private:  
     vector<int> data;  
     int curr;  
     int listSize;  
     int maxSize;  
     public:  
     List(int max=120):maxSize(max+10),listSize(max)  
     {  
         data.resize(max+10);  
         //按最大内容分配  
         curr=0;  
     }  
     int insert(int num)  
     {  
         if(listSize>=maxSize)  
         //若已满，则扩容  
         {  
             resize(maxSize+10);  
             maxSize+=10;  
             listSize++;  
         }  
         for(int i=listSize;i>curr;i--)  
         {  
             data[i]=data[i-1];  
         }  
         data[curr]=num;  
         listSize++;  
     }  
     void resize(int n)  
     {  
         data.resize(n+10);  
     }  
     int remove(int num)  
     {  
         if(curr==listSize)  
         {  
             int empt=curr;  
             curr--;  
             listSize--;  
             return data[empt];  
         }  
         int empt2=data[curr];  
         for(int i=curr+1;curr<=listSize;i++)  
         {  
             data[i-1]=data[i];  
         }  
         listSize--;  
         return empt2;  
     }  
     bool move(int pos)  
     {  
         if(pos<0||pos>=listSize)  
         {  
             return false;  
         }  
         else  
         {  
             curr=pos;  
             return true;  
         }  
     }  
     void moveToStart()  
     {  
         curr=0;  
     }  
     void moveToEnd()  
     {  
         curr=listSize;  
     }  
     void prev()  
     {  
         if(curr>0)  
         curr--;  
     }  
     void next()  
     {  
         if(curr<listSize)  
         curr++;  
     }  
     int length()  
     {  
         return listSize;  
     }  
     int currPos()  
     {  
         return curr;  
     }  
     int getValue()  
     {  
         return data[curr];  
     }  
     void setValue(int num)  
     {  
         data[curr]=num;  
     }  
     void clear()  
     {  
         maxSize=0;  
         listSize=0;  
         resize(0);  
     }  
 };  
 int main(){  
       
 }
```
## List的链表实现

### 单向链表

链（next link）

```cpp
 #include<iostream>  
 using namespace std;  
 template <class E>  
 class link  
 {  
     public:  
     E element;  
     link* next;    
     list(const E&elemval,link* nextval=nullptr)  
     {  
         element=elemval;  
         next=nextval;  
     }  
     list(link* nextval=nullptr)  
     {  
         next=nextval;  
     }  
 };  
 template<class E>   
 class List:public link<E>  
 {  
     private:  
     link<E>* head;  
     link<E>* tail;  
     link<E>* curr;  
     int size;  
     public:  
     List()  
     {  
         curr=tail=head=new link<E>;  
         size=0;  
     }  
     void insert(const E& item)  
     {  
         if(tail==curr)  
         {  
             curr->element=item;  
             tail=curr->next;  
             if(tail==nullptr)  
             {  
                 tail=new link<E>;  
             }  
             size++;  
         }  
         else  
         curr->next=new link<E>(item,curr->next);  
     }  
     void append(const E& item)  
     {  
         tail->element=item;  
         tail=tail->next=new link<E>;  
         size++;  
     }  
     E remove()//去除curr后面的  
     {  
         if(curr->next==tail)  
         {  
             tail=curr;  
         }  
         else  
         link<E>* ltemp=curr->next;  
         E it=ltemp->element;  
         curr->next=curr->next->next;  
         size--;  
         delete ltemp;  
         return it;  
     }  
     void next()  
     {  
         if(curr!==tail)  
         {  
             curr=curr->next;  
         }  
     }  
     void prev()  
     {  
         if(curr!==head)  
         {  
             link<E>* temp=head;  
             while(temp->next!=curr)  
             {  
                 temp=temp->next;  
             }  
             curr=temp;  
         }  
     }  
 };
```
### 双向链表

```cpp
 struct list  
 {  
     int data;  
     list *next;  
     list *prev;  
 };  
 class List  
 {  
     private:  
     int size;  
     list *body;  
     list *head;  
     list *tail;  
     public:  
     List(int i=1)  
     {  
         size=i;  
         body=new list[i];  
         head=new list;  
         head->next=&body[0];  
         head->prev=nullptr;  
         tail=new list;  
         tail->prev=&body[i-1];  
         tail->next=nullptr;  
         body[0].prev=head;  
         body[0].next=&body[i-1];  
         for(int k=1;k<i-1;k++)  
         {  
             body[k].prev=&body[k-1];  
             body[k].next=&body[k+1];  
             body[k].data=0;  
         }  
         body[i-1].prev=&body[i-2];  
         body[i-1].next=tail;  
     }  
     bool insert(int posi,int setin)  
     {  
         if(posi>size)  
         {  
             return false;  
         }  
         list *temp=head;  
         for(int i=0;i<posi;i++)  
         {  
             temp=temp->next;  
         }  
         list *newlist=new list;  
         newlist->data=setin;  
         newlist->next=temp->next;  
         newlist->prev=temp;  
         temp->next=newlist;  
         return true;  
     }  
     bool remove(int posi)  
     {  
         if(posi>size)  
         {  
             return false;  
         }  
         list *pp=head;      
         for(int i=0;i<posi;i++)  
         {  
             pp=pp->next;  
         }  
         list *temp=pp->next;  
         temp->prev=pp;  
         pp->next=temp->next;  
     }  
     list* getHead()  
     {  
         return head;  
     }  
     list* getTail()  
     {  
         return tail;  
     }  
     list* getNext(list *p)  
     {  
         return p->next;  
     }  
     list* getPrev(list *p)  
     {  
         return p->prev;  
     }  
 ​  
 };
```
## 迭代器

1.本身是可迭代的、

2.本身可以访问到下一个元素（指针）

迭代器是STL中数据结构的单位

常量容器和非常量容器使用诸如begin（），end（）方法时返回的迭代器不同，分别为const_iterator和iterator

## vector的实现

`{}` 也可以用于初始化容器类型或其他支持初始化列表的类型。例如，你可以用 `{}` 来初始化一个 `std::vector<int>` 对象
```cpp
 #include<iostream>  
 using namespace std;  
 template <class object>  
 class Vector  
 {  
     public:  
     Vector(int size=0 ):thisSize(size),theCapacity(size+spare)  
     {  
         node=new object[theCapacity];  
     }  
     Vector(const Vector& rhs):theSize(rhs.theSize),theCapacity(rhs.theCapacity),node(nullptr)  
     {  
         node=new object[theCapacity];  
         for(int i=0;i!=thesize;++i)  
         {  
             node[i]=rhs.node[i];  
         }  
     }  
     Vector &operator= (const Vector& rhs)  
     {  
         Vector empt=rhs;  
         swap(*this,empt);  
         return *this;  
     }  
     ~Vector ()  
     {  
         delete [] node;  
     }  
     Vector(Vector &&rhs):theSize(rhs.theSize),theCapacity(rhs.theCapacity),node(rhs.node)  
     {  
         rhs.node=nullptr;  
         rhs.theSize=0;  
         rhs.theCapacity=0;  
     }  
     Vector & operator=(Vector && rhs)  
     {  
         swap(*this,rhs);  
         swap(theSize,rhs.theSize);  
         swap(theCapacity,rhs.theCapacity);  
         return *this;  
     }  
     void resize(int newSize)  
     {  
         if(newSize>theCapacity)  
         {  
             reserver(newSize);  
         }  
         theSize=newSize;  
     }  
     void reserve(int newCapacity)  
     {  
         if(newCapacity<theSize)  
         {  
             return;  
         }  
         object *newArry=new object[newCapacity];  
         for(int i=0;i<theSize;++i)  
         {  
             newArry[i]=node[i];  
         }  
         theCapacity=newCapacity;  
         swao(node,newArry)  
         delete [] newArry;  
     }  
     object &operate[](int index)  
     {  
         return node[index];  
     }  
     const object& operator[](int index)const  
     {  
         return node[inex];  
     }  
     bool empty()const{  
         return size()==0;  
     }  
     int size()const  
     {  
         return theSize;  
     }  
     int capacity()const{  
         return theCapacity;  
     }  
     void push_back(const object &node)  
     {  
         if(theSize==theCapacity)  
         {  
             reserve(2*theCapacity+1);  
         }  
          node[theSize++]=x;  
     }  
     void push_back(onject && x)  
     {  
         if(theSize==theCapacity)  
         {  
             reserve(2*theCapacity+1);  
         }  
         node[theSize++]=std::move(x);  
     }  
     void pop_back()  
     {  
         theSizs--;  
     }  
     const object& back()const{  
         return node[theSize-1];  
     }  
     typedef object* iterator;  
     typedef const object* const_iterator;  
     iterator begin()  
     {  
         return &node[0];  
     }  
     const_iterator begin()const{  
         return &node[0];  
     }  
     iterator end()  
     {  
         return &node[theSize];  
     }  
     const_iterator end()  
     {  
         return &node[theSize];  
     }  
     static const int spare=16;  
     private:  
     object *node;  
     int theSize;  
     int theCapacity;  
 };
```
## 栈ADT

### 栈的链表实现

```cpp
 #include<iostream>  
 using namespace std;  
 template <class E>  
 class link  
 {  
     public:  
     E element;  
     link* next;    
     list(const E&elemval,link* nextval=nullptr)  
     {  
         element=elemval;  
         next=nextval;  
     }  
     list(link* nextval=nullptr)  
     {  
         next=nextval;  
     }  
 };  
 template <class E>  
 class Stack  
 {  
     private:  
     void opertaor=(const Stack&);  
     Stack(const Stack&);  
     public:  
     virtual bool push(const E& item)=0;  
     virtual E pop()=0;  
     virtual const E& top() const=0;  
 };  
 template <class E>  
 class LStack:public Stack<E>  
 {  
     private:  
     link<E>* top;  
     int size;  
     public:  
     LStack(int sz=10)//default  
     {  
         top=nullptr;  
         size=0;  
     }  
     ~LStack()  
     {  
         clear();  
     }  
     void clear()  
     {  
         while(top!=nullptr)  
         {  
             link<E>* temp=top;  
             top=top->next;  
             delete temp;  
         }  
         size=0;  
     }  
     void push(constE& item)  
     {  
         top=new link<E>(item,top);  
         size++;  
     }//每次push，都会新建一个节点，他的next是上一个节点，top始终在栈顶  
     E pop()  
     {  
         if(size>0)  
         {  
             E it=top->element;  
             link<E>* empt=top;  
             top=top->next;  
             size--;  
             delete empt;  
             return it;    
         }  
     }  
     constE& topValue()const{  
         return top->element;  
     }  
 };  
```
### 栈的数组实现

使用vector的pop，push等实现

```cpp
 #include<iostream>  
 using namespace std;  
 template <class E>  
 class Stack  
 {  
     private:  
     void opertaor=(const Stack&);  
     Stack(const Stack&);  
     public:  
     virtual bool push(const E& item)=0;  
     virtual E pop()=0;  
     virtual const E& top() const=0;  
 };  
 template <class E>  
 class AStack:public Stack<E>  
 {  
     private:  
     int maxsize;  
     int top;//top领先实值  
     E* listArry;  
     public:  
     AStack(int size=10)//default  
     {  
         maxsize=size;  
         top=0;  
         listArry=new E[maxsize];  
           
     }  
     ~AStack()  
     {  
         delete []listArry;  
     }  
     void push(const E& item)  
     {  
         if(top<maxsize)  
         {  
             listArry[top++]=item;  
         }  
     }  
     E pop()  
     {  
         return listArry[--top];  
     }  
     const E& topValue() const  
     {  
         return listArry[top-1];  
     }  
     void clear()  
     {  
         top=0;  
     }  
 ​  
 }
```
### 中序遍历的实现（栈）

## 队列

### 队列的数组实现

 考虑到普通队列使用数组实现会导致空间的大量浪费，故使用循环队列  
 事实上，以数组实现的队列满与空要看初始条件，在下面的例子中，由于空间多加了1位，所以初始条件位rear=0，front=1，此时队列自然为空（差值为1），队列是否为空也要靠这个判断。若差值为2，则自然为满  
 若初始条件不会扩充空间，那么设置rear=0，front=0；差值为0，队列为空，差值为1，队列为满  
```cpp
 #include<iostream>  
 using namespace std;  
 template <class E>  
 class Queue  
 {  
     private:  
     void operator=(const Queeue&){};  
     Queue(const Queue&){};  
     public:  
     Queue(){};  
     virtual ~Queue()=0;  
     virtual void clear()=0;  
     virtual void enqueue(const E& x)=0;  
     virtual E dequeue()=0;  
     virtual const E& frontValue()const=0;  
     virtual int length()const=0;  
 };  
 template <class E>  
 class AQueue:public Queue<E>  
 {  
     private:  
     int maxSize;  
     int front;  
     int rear;  
     E* array;  
     //int currSize;可用于检测是否溢出  
     public:  
     AQueue(int size=10)//default  
     {  
         maxSize=size+1;  
         rear=0;  
         front=1;  
         listArry=new E[maxSize];  
           
     }  
     ~AQueue()  
     {  
         delete []listArry;  
     }  
     void clear()  
     {  
         rear=0;  
         front=1;  
     }  
     void enqueue(constE& item)  
     {  
         if((rear+2)%maxSize!=front)  
         {  
             rear=(rear+1)%maxSize;  
             listArry[rear]=item;  
         }  
     }  
     E dequeue()  
     {  
         E item=listArry[front];  
         front=(front+1)%maxSize;  
         return item;  
     }  
     const E& frontValue()const{  
         return listArry[front];  
     }  
     virtual int length()const{  
         return (rear+maxSize-front)%maxSize;  
     }  
 ​  
       
 };

```
### 队列的链表实现

```cpp
//不考虑使用循环列表  
 #include<iostream>  
 using namespace std;  
 template <class E>  
 class link  
 {  
     public:  
     E element;  
     link* next;    
     list(const E&elemval,link* nextval=nullptr)  
     {  
         element=elemval;  
         next=nextval;  
     }  
     list(link* nextval=nullptr)  
     {  
         next=nextval;  
     }  
 };  
 template <class E>  
 class Queue  
 {  
     private:  
     void operator=(const Queeue&){};  
     Queue(const Queue&){};  
     public:  
     Queue(){};  
     virtual ~Queue()=0;  
     virtual void clear()=0;  
     virtual void enqueue(const E& x)=0;  
     virtual E dequeue()=0;  
     virtual const E& frontValue()const=0;  
     virtual int length()const=0;  
 };  
 template <class E>  
 class LQueue:public Queue<E>  
 {  
     //存在两种方法，一是留下一个空的节点，一个是不留，本方法采用后者，因为前者易实现  
     private:  
     int maxSize;  
     link* front;  
     link* raer;  
     int len;  
     public:  
     AQueue(int size=10)//default  
     {  
         maxSize=size;  
         front=nullptr;  
         rear=nullptr;  
     }  
     ~AQueue()  
     {  
         while(front!=nullptr)  
         {  
             link* empt=front;  
             front=front->next;  
             delete empt;  
         }  
     }  
     void clear()  
     {  
         while(front!=nullptr)  
         {  
             link* empt=front;  
             front=front->next;  
             delete empt;  
         }  
         rear=nullptr;  
         front=nullptr;  
         len=0;  
     }  
     void enqueue(constE& item)  
     {  
         if(len==0)  
         {  
             link* empt=new link(item);  
             front=empt;  
             rear=empt;  
         }  
         else{  
             link* empt=new link(item);  
             rear->next=empt;  
             rear=empt;  
         }  
         len++;  
     }  
     E dequeue()  
     {  
         if(front!=rear)  
         {  
             E item=front->element;  
             link* empt=front;  
             front=front->next;  
             delete empt;  
             len--;  
         }  
     }  
     const E& frontValue()const{  
         return front->element;  
     }  
     virtual int length()const{  
         return len;  
     }  
 ​  
       
 };
```
# 树

根：无父

节点：

树叶：有父无子

兄弟：有相同父亲

路径：两节点间的线段数量

深度：根到该节点的线段数

高：该点到最远的叶节点

真祖先--真后裔：父子不相等

## 树的实现

考虑到为每个节点设置超出实际范围的指针数不灵活，改为为每个节点设置指向下一个兄弟和自己的儿子的指针。
```cpp
#include<iostream>  
 using namespace std;  
 template <class object>  
 struct treeNode  
 {  
     object data;  
     treeNode* brother;  
     treeNode* child;  
 };  
 ​  
```
## 树的遍历

### 先序遍历：

根--左子树---右子树

### 中序遍历：

左子树--根---右子树

### 后续遍历：

左子树--右子树---根

### 遍历实现

```cpp
void preorder(treeNode* Tree)  
     {  
         if(Tree==NULL)  
         return;  
         cout<<Tree->data<<" ";  
         preorder(Tree->left);  
         preorder(Tree->right);  
         return;  
     }  
     void preorder(tree* Tree)  
     {  
         preorder(root);  
     }  
     void ineorder(treeNode* Tree)  
     {  
         if(Tree==NULL)  
         return;  
         preorder(Tree->left);  
         cout<<Tree->data<<" ";  
         preorder(Tree->right);  
         return;  
     }  
     void ineorder(tree* Tree)  
     {  
         ineorder(root);  
     }  
     void postorder(treeNode* Tree)  
     {  
         if(Tree==NULL)  
         return;  
         preorder(Tree->left);  
         preorder(Tree->right);  
         cout<<Tree->data<<" ";  
         return;  
     }  
     void postorder(tree* Tree)  
     {  
         postorder(root);  
     }
```
## 二叉树

每个节点的儿子数不多于2

### 二叉查找树

左子树的所有值小于根，右子树的所有值大于根

#### 表达式树

叶为操作数，节点为操作符。以三种不同的遍历方式能得到三种不同的表达式

即从先序等三种遍历的结果回溯到原本的树

## 二叉查找树

### 实现

### find
```cpp
#include<iostream>  
 using namespace std;  
 template <class E>  
 class BinNode  
 {  
     public:  
     virtual E& element()=0;  
     virtual void setElement(E&)=0;  
     virtual BinNode<E>* left()=0;  
     virtual BinNode<E>* right()=0;  
     virtual void setLeft(BinNode<E>*)=0;  
     virtual void setRight(BinNode<E>*)=0;  
     virtual bool isLeaf()=0;  
 };  
 template <class E>  
 class BinaryNode:public BinNode<E>  
 {  
     public:  
     E element;  
     BinaryNode* leftChild;  
     BinaryNode* rightChild;  
     BinaryNode(const E& theElement,BinaryNode* lt,BinaryNode* rt):element(theElement),leftChild(lt),rightChild(rt){}  
 };  
 template <class E>  
 class BinarySearchTree:public BinaryNode<E>  
 {  
     public:  
     bool contains(const E& x,BinaryNode* t)const  
     {  
         if(t==nullptr)return false;  
         else if(x<=t->element)return contains(x,t->left());  
         else if(x>=t->element)return contains(x,t->right());  
         else return true;  
     }  
 };

findMax和findMin

 class BinarySearchTree:public BinaryNode<E>  
 {  
     public:  
     BinaryNode* findMin(BinaryNode* t)const{  
         if(t==nullptr)return nullptr;  
         if(t->left()==nullptr)return t;  
         return findMin(t->left());  
     }  
     }  
 };

insert

     void insert(const E& x,BinaryNode* &t)//注意&  
     {  
         if(t==nullptr)  
         t=new BinaryNode<E>(x,nullptr,nullptr);  
         else if(t->element<x)return insert(x,t->left);  
         else if(t->element>x)return insert(x,t->right);  
         else return;  
     }

delete

     void Delete(const E&x,BinaryNode*& t)  
     {  
         if(t==nullptr)return;  
         if(x<t->element)Delete(x,t->left);  
         else if(x>t->element)Delete(x,t->right);  
         else if(t->left()!=nullptr&&t->right()!=nullptr)  
         {  
             BinaryNode* tmp=findMin(t->right());  
             t->element=tmp->element;  
             Delete(tmp->element,t->right());  
         }  
         else  
         {  
             BinaryNode* oldNode=t;  
             t=t->left()!=nullptr?t->left():t->right();  
             delete oldNode;  
         }  
     }
```
## AVL

是二叉搜索树的衍生，但就平衡问题展开旋转操作

### 旋转

#### 单旋
```cpp
  void rotateWithLeftChild(AvlNode*& t)//左左的单旋转，即单旋中的右旋  
     //使用&确保我们操作的对象是t的父节点parent的parent->left  
     //好比两个指针指向同一个空间，但是改变其中一个指针的指向不会影响另一个指针一样  
     {  
         AvlNode* newTop=t->left;//新根节点  
         t->left=newTop->right;//易子  
         newTop->right=t;//交替  
         t=newTop;//变根  
 ​  
         t->right->height=max(height(t->right->left),height(t->right->right))+1;  
         t->height=max(height(t->left),height(t->right))+1;  
         //不需要更新左子树的高度，因为没有改动  
 ​  
     }//中间节点的右子变为原根节点的左子
     void rotateWithRightChild(AvlNode*& t)//单旋中的左旋  
     {  
         AVlNode* newTop=t->right;  
         t->right=newTop->left;  
         newTop->left=t;  
         t=newTop;  
 ​  
         t->left->height=max(height(t->right->left),height(t->right->right))+1;  
         t->height=max(height(t->left),height(t->right))+1;  
     }//中间节点的左子变为原根节点的右子
```
#### 双旋

```cpp
     void doubleWithLeftChild(AvlNode*& t)//双旋中的右旋，只使用于目标节点左孩子的左孩子为空  
     {  
         // Step 1: 先对 t->left 进行单右旋转 (即左旋转)  
         rotateWithRightChild(t->left);  
 ​  
         // Step 2: 再对 t 进行单左旋转 (即右旋转)  
         rotateWithLeftChild(t);  
     }  
     void doubleWithRightChild(AvlNode*& t)  
     {  
         rotateWithLeftChild(t->right);//先左  
         rorateWithRightChild(t->left);//后右  
     }

```
AVL树的旋转，归结为：
自从下往上第一个不平衡的节点起，向下按顺序寻找两个节点（若这两个节点的形状机符合单旋转，又符合双旋转，则取单旋转），将这三个节点排序，原来的不平衡节点的父节点放置在先已经排序的根节点上，其余的子节点按原旋转方法放置。
### 高度

```cpp
     int height(AvlNode* t)const  
     {  
         return t==nullptr?-1:t->height;  
     }
```
### 插入

```cpp
    void insert(const E& x,AvlNode*&t)  
     {  
         if(t==nullptr)  
         {  
             t=new AvlNode{x,nullptr,nullptr};  
         }  
         else if(x<t->data)  
         {  
             insert(x,t->left);  
         }  
         else{  
             insert(x,t->right)  
         }  
         balance(t);  
     }

```
### 平衡

```cpp
    void balance(AvlNode* & t)  
     {  
         if(t==nullptr)return;  
         if(height(t->left)-height(t->right)>IMBALANCE)  
         {  
             if(height(t->left->left)>=height(t->left->right))  
             {  
                 rotateWithLeftChild(t);//单旋，左左  
             }  
             else  
             {  
                 doubleWithLeftChild(t);//双旋，左右  
             }  
         }  
         else  
         {  
             if(height(t->right)-height(t->left)>IMBALANCE)  
             {  
                 if(height(t->right->right)>=height(t->right->left))  
                 {  
                     rotateWithRightChild(t);  
                 }  
                 else{  
                     doubleWithRightChild(t);  
                 }  
             }  
         }  
         t->height=max(height(t->left),max(t->right))+1;  
     }
```
### 删除

```cpp
  void delete(const E&x,AvlNode*& t)  
     {  
         if(t==nullptr)return;  
 ​  
         if(x<t->element)Delete(x,t->left);  
 ​  
         else if(x>t->element)Delete(x,t->right);  
 ​  
         else if(t->left()!=nullptr&&t->right()!=nullptr)  
         {  
             BinaryNode* tmp=findMin(t->right());  
             t->element=tmp->element;  
             Delete(tmp->element,t->right());  
         }  
         else  
         {  
             BinaryNode* oldNode=t;  
             t=t->left()!=nullptr?t->left():t->right();  
             delete oldNode;  
         }  
         balance(t);  
     }
```

注：每次balance都会重新矫正这层的高度，因此放在顺序结构的最下层，以便递归时从小到大的进行balance

## 伸展树

### find

伸展树的每次find都会使被访问到的节点旋转到根节点

![](https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006141941.png)

![](https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006141957.png)

### 展开

![](https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006142020.png)
看上去就像是移动了两个节点（仅对“一字型"而言），其余一致
注：因为伸展树的旋转树是硬转，可能平衡，也可能不平衡，故有时为了把目标节点旋转到根节点的位置，需要补充空节点。其余与AVL一致
### 插入

即正常插入值后再将其旋转到根上

### 删除

访问一次该节点，置到根上后删除，取左子树的最大值，展开到根，原本的右子树作为现在的根的右子树

## B树

B树相比于二叉树，有更多的子代。

### 特点

1. 数据项存储在叶上
    
2. 阶数(order)M表示节点最大的子数数量，因此其最多可以存储M-1个关键字，第i个关键字代表第i+1个子树的最小值
    
3. 根的儿子数在2~M之间
    
4. 非叶非根节点的孩子数在int（M/2）+1（向上取整）~M之间，关键词数另计
    
5. 所有叶节点存储的数据项数在int（L/2）+1（向上取整）~L之间


### B+树

![](https://raw.githubusercontent.com/lafaeier/PicBed/image/img/Pasted%20image%2020241006142037.png)

如上图，B+树适用于数据库索引，按键值排序，并且每个叶节点之间用指针链接

### B-树

B-树实际上就是B树，我们通常把叶节点用指针链接起来的B-树称为B+树

#### 查找
```cpp
Find(ElementType K, Btree T){

  B = T;//B表示当前节点

  while (B is not a leaf){

   find the Pi in node B that points to the proper subtree that K will be in;

   B = Pi;

}

/* Now we’re at a leaf */

if key K is the jth key in  leaf  B,

   use the jth record pointer to find the

   associated record;

else /* K is not in leaf B */ report failure;
}

```
##### 查找过程讲解：

1. **初始化**：从树的根节点 `T` 开始，将当前节点 `B` 设置为根节点 `T`，即 `B = T`。这个过程是从根开始的，因为 B-树的查找和普通树的查找类似，都是从根节点依次向下递归进入子树进行查找。
    
2. **遍历非叶节点**：
    
    - 伪代码中的 `while (B is not a leaf)` 意味着查找过程中只要没有到达叶子节点，就继续向下查找。
    - 在非叶节点中，B-树节点包含多个关键字，每个关键字对应一个范围，将关键字 `K` 与当前节点的关键字进行比较，找到 `K` 所在的范围，确定 `Pi`，即指向合适子树的指针。
    - 找到正确的子树后，将当前节点 `B` 设为该子树的根节点，即 `B = Pi`，继续遍历子树。
3. **进入叶节点**：
    
    - 当遍历到叶子节点时，循环结束，此时 `B` 是一个叶子节点。
    - B-树的所有数据记录或数据的指针都存储在叶子节点中，因此需要在叶子节点上确认是否包含要查找的关键字 `K`。
4. **查找关键字**：
    
    - 如果关键字 `K` 存在于当前叶子节点 `B` 中，且是第 `j` 个关键字，则通过 `j` 对应的记录指针找到与 `K` 相关的记录。
    - 如果在叶子节点中没有找到 `K`，即关键字不在当前节点中，报告查找失败。

##### B-树查找的核心思想

- **分层查找**：B-树的查找是通过逐层向下，逐渐缩小查找范围的过程。每次查找都通过在非叶节点中找到指向子树的指针，递归地进入对应子树，直到最终找到或确认关键字不存在。
    
- **多路分支**：每个B-树节点（尤其是非叶节点）通常包含多个关键字，因此每个节点的查找类似于在多个范围中确定属于哪一个范围，并选择相应的子树。
    
- **叶子节点存储数据**：B-树的叶子节点保存了所有关键字及其相关数据或指针，因此最终查找的结果都会在叶子节点中完成。
#### 插入
```cpp
Insert(ElementType K, Btree B)

{

   find the leaf node LB of B in which K belongs;

   if notfull(LB) insert K into LB;

   else {

     split LB into two nodes LB and LB2 with

      j = int((L+1)/2) keys in LB and the rest in LB2;

       if ( IsNull(Parent(LB)) )

           CreateNewRoot(LB, K[j+1], LB2);

       else

           InsertInternal(Parent(LB), K[j+1], LB2);   

       }
}

```
##### 插入过程讲解

1. **找到合适的叶节点**：
    
    - 首先，通过B-树的查找过程，找到`K`应该插入的叶子节点 `LB`。这和查找操作类似，即从根节点开始，逐步向下寻找正确的叶子节点。
2. **检查叶子节点是否有空位**：
    
    - 如果 `LB` 还没有满，直接将关键字 `K` 插入 `LB` 中合适的位置。这个步骤相对简单，因为B-树的节点是有序的，插入时需要保持节点内的关键字顺序。
3. **叶子节点满时的分裂**：
    
    - 如果叶子节点 `LB` 已经满了，则需要进行分裂操作。具体步骤如下：
        - 将叶子节点 `LB` 分成两个节点 `LB` 和 `LB2`。
        - 设 `j = (L+1)/2`（向下取整），即计算将原叶子节点中的关键字一分为二的位置。分裂后，`LB` 保留前 `j` 个关键字，剩下的关键字放入新节点 `LB2` 中。
4. **处理父节点**：
    
    - 分裂节点后，需要将中间的关键字（`K[j+1]`，即分裂过程中跨越两个节点的中间关键字）插入到父节点中，以保持B-树的结构。
        
    - 如果 `LB` 没有父节点，说明 `LB` 原来是根节点，这种情况下需要创建一个新的根节点。新的根节点会包含 `K[j+1]` 作为它的唯一关键字，并且指向两个子节点 `LB` 和 `LB2`。
        
    - 如果 `LB` 有父节点，则将 `K[j+1]` 插入到 `LB` 的父节点中，并且父节点要处理 `LB2` 作为新的子节点的情况。这个过程可能导致父节点再次溢出，从而需要递归地进行分裂和插入操作。
        
5. **递归处理父节点插入**：
    
    - 如果父节点在插入新关键字时再次溢出，那么需要重复上述分裂和插入的过程，直到没有溢出的情况为止。这个过程可能会从叶子节点一直递归到根节点，最终可能会导致整个树的高度增加。

##### 插入的核心思想

- **局部调整**：B-树的插入操作优先在叶子节点进行。如果叶子节点有空位，插入操作只会影响该叶子节点，不需要对树做任何调整。
    
- **分裂节点**：当节点满时，必须将其分裂为两个节点，并将中间关键字提升到父节点。这种机制确保了B-树的节点不会超过预定的容量上限。
    
- **递归调整父节点**：如果父节点也因为插入新关键字而满了，同样需要进行分裂，并将中间关键字继续提升。这个过程可能递归到根节点。如果根节点溢出，则需要创建一个新的根节点，树的高度因此增加
注：叶节点与其父节点之间可以存在重复元素，但其他的则不行
#### 删除
##### B-树删除操作的过程

B-树的删除主要包括以下步骤：

1. **找到要删除的关键字所在的节点**：
    
    - 通过类似查找操作的方式，从根节点出发，找到包含要删除关键字 `K` 的叶子节点或非叶节点。
2. **删除的三种情况**： 删除操作根据关键字所在的位置分为三种情况来处理。
    
    - **情况1：关键字在叶子节点**  
        如果要删除的关键字 `K` 在叶子节点，且删除不会导致叶子节点的关键字数目低于最低要求（即至少有 ⌈m/2⌉−1\lceil m/2 \rceil - 1⌈m/2⌉−1 个关键字，其中 `m` 是B-树的阶数），那么可以直接删除该关键字，不需要额外调整。
        
        **例子**：如果叶子节点中有足够的关键字（比如超过最低要求），可以直接删除 `K` 而不破坏B-树的结构。
        
    - **情况2：关键字在非叶节点**  
        如果要删除的关键字 `K` 位于非叶节点，那么有两种方法处理：
        
        1. **用前驱替换**：找到 `K` 在该节点左子树中的最大关键字（即`K`的**前驱**），将其替换 `K`，并在前驱所在的叶子节点中删除该前驱。
        2. **用后继替换**：找到 `K` 在该节点右子树中的最小关键字（即`K`的**后继**），将其替换 `K`，并在后继所在的叶子节点中删除该后继。
        
        删除后递归处理前驱或后继的删除情况。
        
    - **情况3：关键字在叶子节点中且删除会导致关键字数目不足**  
        如果删除关键字 `K` 后，叶子节点中的关键字数目低于最低要求，就需要进行**借位**或**合并**操作来恢复B-树的平衡：
        
        1. **借位**：如果 `K` 的兄弟节点有多于最低要求的关键字，则可以从兄弟节点中借一个关键字。借位过程通过父节点调整关键字，使得父节点的某个关键字“下移”到当前节点，同时从兄弟节点“上移”一个关键字到父节点。
            
        2. **合并**：如果 `K` 的兄弟节点也只包含最低数量的关键字，则将当前节点和其兄弟节点**合并**，并将父节点中的一个关键字下移到合并后的节点。合并后，如果父节点关键字数目不足，可能需要对父节点递归进行合并或借位。
如图
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241007194010.png>
删除17，则13，14，18合并，二级节点的17同时被删除，向其兄弟节点借来11，兄弟的子节点中大于11的索引同步过来。
## set与map
由于其内核都为红黑树，故放在此处讨论，各方法详见STL
### set的实现与map的实现
为该进iterator，使用线索树，在iterator中设置一个bool，不同的值对应左子树还是右子树使用线索的表示
# 散列
1. 散列是一种用于以常数时间插入，删除和查找的技术。
    
2. 散列通过将数据组使用散列函数得到的值作为索引，以达到类似于数组的效果
    
3. 散列函数也通常用来加密数据库中的密码，其具有不可逆性，既不能通过散列值得到原本的值
    
4. 散列是将较大范围的值映射到较小范围内的，这不可避免的会出现带入值不同而散列值一致的情况。
	
5. 专用于查找与插入为`o(1)`的情况
## 为什么不使用数组？
- **节省空间**：直接分配一个大数组意味着要为每个可能的键值分配内存。比如，如果你的键值范围是 0 到 10亿，分配一个长度为 10亿的数组会占用大量的内存，而实际上你可能只需要存储几百个或几千个键值。散列表通过散列函数将键值映射到一个较小的索引空间，因此更加节省空间。
    
- **灵活的键类型**：如果键不是简单的整数，而是字符串、对象等复杂类型，直接用这些键作为数组索引是不现实的。散列函数可以将这些复杂键映射为一个整数索引，从而适应更灵活的键类型。
    
- **更快的查找速度**：散列表的查找、插入和删除操作在理想情况下可以达到常数时间复杂度 O(1)O(1)O(1)，相比线性查找数组中的元素快得多。散列函数直接计算出索引，不需要遍历数组。
## 应用
1. 作为散列表                                                                                                                                      
2. 对比验证信息传输的正确性
3. 对比散列值矫正数据错误
4. 数据库索引
5. cache
6. 密码学
7. 用于在RAM上查找数据
## 散列表（哈希表）
通过键值直接访问的一种数据结构
### 碰撞（冲突）
不同的关键字得到相同的哈希值
### 构造散列函数
#### 直接定址法
哈希值为本身的方法，需要关键字连续且范围较小
#### 数字分析法
排除连续关键字中相同的或者具有相同特征的位，取剩余的位合并为一个哈希值
#### 平分取中法
将关键字平方后取特定连续位数的一种方法
#### 折叠法
将本身较长的关键字分为均匀的几个部分，在将他们自低位对齐后相加得到哈希值
#### 随机值
取关键字的随机函数值作为哈希值
#### 除留余数法
对于表长为m的哈希表，取值p<=m，使hash(k)=k%p;p一般取接近m的素数或m本身
#### 减去法
相当于直接定址法，只不过减去了一个固定的值使得索引可以从较小的值开始，如0，1，2...
#### 基数转换法
将十进制的关键字视为与十互素的进制，再转换为十进制
#### 字符串数值哈希法
适用于关键字使字符串的情况
## 处理冲突（碰撞）
### 聚集
由于大部分散列函数的结果从总体上看是不连续且显著集中分布的，故聚集情况常常出现
### 装填因子

   $$Load factor=\frac{n}{k}$$其中，n是哈希表中的条目数，k是哈希表的大小，负载因子越大，n越接近k，哈希表越慢
有访问时间$O（1）+O（\lambda )$。
#### 开放定址法
即项目的地址不是由其哈希值决定的。
   $$H_i=(H(key)+d_i)\%m,i=1,2,3...$$
其中$H（key）$为哈希函数，m为表长，$d_i$为增量序列

#### 分类
假定关键字%10的结果为散列函数，若插入时空间已经满了，那么则执行以下的方法，使得重新选址
##### 线性探测（注）
增量序列一般固定为1，即$d_i$=1，线性探测倾向于使散列表填满，但这会大大减慢单列表的速度。同时，也会引发**一次聚集**问题，即散列表中的某个区块全部被占用，此时需要的插入的时间就大大延长了

| 散列地址 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 未插入  |     |     |     |     |     |     |     |     |     |     |
| 插入89 |     |     |     |     |     |     |     |     |     | 89  |
| 插入18 |     |     |     |     |     |     |     |     | 18  | 89  |
| 插入49 | 49  |     |     |     |     |     |     |     | 18  | 89  |
| 插入58 | 49  | 58  |     |     |     |     |     |     | 18  | 89  |
| 插入69 | 49  | 58  | 69  |     |     |     |     |     | 18  | 19  |
当计算的散列值对应的空间已经满了，那么就在线性探测中使用公式，依次向后移动
##### 平方探测（注）
取增长序列为$d_i=(i\%10)^2$
平方探测可以解决线性探测的一次聚集问题。
有定理：**如果使用平方探测，表的大小是素数，且表的一半及以上是空的，那么总能成功插入一个素数**。
但这也引发了二次聚集问题。

| 散列地址 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 未插入  |     |     |     |     |     |     |     |     |     |     |
| 插入89 |     |     |     |     |     |     |     |     |     | 89  |
| 插入18 |     |     |     |     |     |     |     |     | 18  | 89  |
| 插入49 | 49  |     |     |     |     |     |     |     | 18  | 89  |
| 插入58 | 49  |     | 58  |     |     |     |     |     | 18  | 89  |
| 插入69 | 49  |     | 58  | 69  |     |     |     |     | 18  | 89  |
##### 双重哈希
使用哈希值的随机函数取得。
### 链地址法
#### 链接列表分开存储
开放定址法是将重复的地址转换为不重复的地址，而此方法将所有重复的地址放在一起。
这种方法的基本思想是把所有哈希地址为i的元素构成一个称为同义词链的单链表，并将其头指针存放在哈希表的第i个单元中。
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008231802.png style="zoom:67%;" />
#### 列表头单元格分开链接
将第一条记录放置在单元格内，并设置一个指针以访问下一条同地址的记录。
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232113.png  style="zoom:67%;" />
#### 分离链接法
可以将存储的信息放置到链表中，每条链表的代表每个同地址的记录，单元格存放链表的头指针。
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232324.png style="zoom:67%;" />
### 多重哈希法
#### 再哈希法
$$hash=H1(H1(key))$$
即当一次哈希函数的计算后发现地址重复，则再次将哈希值带入哈希函数进行计算，直到地址不再重复。此方法可以避免聚集，但计算量大，用时长。
#### 建立公共溢出区
即将重复地址的元素放置到溢出区中。
#### 双散列（注）
取增长序列为$d_i=i·H2(key)$,有此，哈希函数hash2的结果不能为0。
对于此方法，算出H2后，用i遍历插入尝试，i的范围是0到散列表的最大值－1。

### 再散列
顾名思义，当我们认为表的大小足够，不得不补充空间时，使用再散列。再散列将散列表的大小扩展为原大小的两倍以上的第一个素数。
有三种方法判断是否需要再散列。
1. 表到一半满是再散列
    
2. 插入失败时在散列
	
3. 增长因子到达一定值时再散列（推荐）
## 完美散列
在分离链接法中，我们知道链表的数量越多，查找所需的时间越少。对于链表的个数M以及项数N,当$M＝N^2$时，最小有1/2的概率不会发生冲突，但直接使用这么多的链表不切实际，故使用完美散列，如下图
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241008232415.png style="zoom:50%;" />

每个单元格中的项数平方后的值为此单元格对应的链表数。这样既能保证较小概率冲突，又能减少链表的数量。
### 杜鹃散列

在杜鹃散列中，我们维护两个散列表，每个都多于半空，再提供两个散列函数，每个函数都能访问到一个散列表。对于要插入的项，两个散列表各有一个对应的位置可供插入。
#### 步骤
两个散列表分别称之为A表和B表
1. 项先插入A表
	
2. 若A表对应的是空，则插入；反之，依旧插入，但是原位置的项移动到表二的对应位置
	
3. 若移入B表的位置也不为空，则依旧放置，原位置的项向A表寻找位置
如下：
1. 插入A项
	<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093135.png>
2. 插入B项
	<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093159.png>
3. 插入CDE三项
	<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093347.png>
诸如上面
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009093556.png>
观察发现，六个项中，A表占了3个，B表占了3个，此杜鹃散列最多容纳6个项，若再尝试在（1，2）位置插入G，则会引发循环。
实现及使用时要把装填因子维持在0.5以下
#### 实现
留待补充

### 跳房子散列 

跳房子散列维护一个散列表，表中有三个元素：**散列值**，**项**，**HOP**
**散列值**：插入一个元素，首先就是要判断其散列值，散列值一致的即可插入
**项**：插入该单元的项的名称
**Hop**： 跳房子散列给出了一个值MAX_DIST，它标志着一个表中的单元可探测的最大范围，即对于散列值重复的项，可以放置的最大个数。

<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009235130.png style="zoom:67%;" />
在上图中，此值为4，故Hop格中有4个值，从左到右以依次表示本格，下一格，+2格，+3格的存放情况，为1，表示对应的单元格中存放了一个相同散列值的项
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241009235936.png>
现在尝试模拟此过程：
1. 插入项H，散列值为9。但9被占据，故尝试在其相邻的3格中寻找空位
	
2. 找不到空位，考虑将这三格中的元素移到三格之外
	
3. 对于10，存放的不是散列值为10的项，移动会破坏表（因为无法记录），放弃10.
	
4. 对于11，存在一个放置在本格的项G，可以将他放置在最大值13处，并将Hop修改为0010
	
5. 插入H，9的Hop更新为1010
## 通用散列
散列表的性质依赖于
1. 散列函数必须常数时间可计算
2. 散列函数必须均匀的分布项
## 可扩散列
**可扩散列**（Extendible Hashing）是一种动态哈希表实现方法，特别适用于数据规模变化频繁的场景。它的设计目的是在保持哈希表高效的同时，能够自动扩展或收缩，从而减少重哈希（rehashing）的开销。
维护一个**目录**：存放项的前n值，当只有1项时，延申出两个块存放项；有n项时以$2^n$的二进制形式增加块
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241010145549.png>
如上，可扩散列还存在一个**深度**：表示项中被用于区分的位的数目
# 优先队列
一台电脑面对许多个用户的访问时，会将这些访问放入队列，先发起访问的先使用计算机资源，但是我们希望他能够优先处理完资源较小的请求，因此，设计优先队列。
优先队列会弹出最小的请求，也能对加入的请求排序。
## 二叉堆
堆是一颗完全填满的树，要实现其完全填满的特性，每次插入都要从左往右填满一行再去考虑下一行，如下图所示：

这样实现的二叉堆完全可以实现使用数组表示，而非使用链表。
### 堆序性质
1. 堆的最小元在根处，节点的值比两个子都要小
2. 堆是完全二叉树
### 堆的操作

```cpp
template <typename Comparable>
class BinaryHeap
{
	public:
	explicit BinaryHeap(int capacity=100);
	ecplicit BinaryHeap(const vector<Comparable>& items);
	
	const Comparable& findMin()const;
	void insert(const Comparable &x);
	void insert(Comparable &&x);
	void deleteMin();
	void deleteMin(Comparable & minItem);
	private:
	int currentSize;
	vector<Comparable> arry;
	void buildHeap();
	void percolateDown(int hole);
}
```

### 堆的操作
#### 插入(上滤)（insert）
时间 `O(log N)` 
将一个值插入二叉堆，则从最下一层寻找空位，然后以此空位向上寻找合适的位置，若值比插入的大，则交换，否则插入完成。
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011223143.png>

```cpp
void insert(const Comparable&x)
{
	if(currentSize==array.size()-1)
	array.resize(array.size()*2);
	int hole=++currentsize;
	Comparable copy=x;
	
	array[0]=std::move(copy);//最后与array[0]比较，而不用每次循环再次判断
	for(;x<array[hole/2];hole/=2)
	{
		array[hole]=std::move(array[hole/2]);
	}
	array[hole]=std::move(array[0]);
	
}
```

#### 删除最小元（deleteMin）
时间`O（logN）`
将根节点置空，再将最后一个节点提取出来（用来填补被上移的空余）然后向下比对两个子，取最小的上移，直到到达最后一列
<img src=https://cdn.jsdelivr.net/gh/lafaeier/PicBed@image/img/20241011230657.png>
这种方法也叫下滤(**percolateDown**),即将一个节点向下比较移动的过程。

```cpp
void deleteMin(Comparable & minItem)
{
	if(isEmpty())
		throw UnderflowException;
	
	minItem=std::move(array[1]);//将最小值赋值到minItem上
	array[1]=std::move(array[currentSize--])；
	
	percolateDown(1);
}
void percolateDown(int hole)
{
	int child;//下面的节点
	Comparable tmp=std::move(arryay[hole]);
	for(;hole*2<=currentSize;hole=child)
	{
		child=hole*2;//左孩子
		if(child!=currentSize&&array[child+1]<array[child])
		{
			++child;//右孩子更小
		}
		if(array[child]<tmp)
		{
			array[hole]=std::move(array[child]);
		}
		else//到头了
			break;
	}
	array[hole]=std::move(tmp);
}
```

#### 降低节点值（decreaseKey）
`decreaseKey(p,k)`，对节点p的关键字降低K的绝对值，并上滤。
#### 增加节点值（increaseKey）
同上
#### 删除（remove）
`remove(p)`，要将p删除，需要使用上滤将p移到根处，在执行deleteMin。
#### buildHeap（构建堆）
时间`平均O(N),最坏O(NlogN)`

```cpp
void buildHeap()
{//假设数据已经填入数组
	for(int i=currentSize/2;i>0;i++)
	{
		percolateDown(i);//从非叶子节点层层下滤
	}
}
```

先使用完全树直接插入，在使用下滤排序
### 应用
#### 堆排序
#### 事件模拟
## d堆
所有的节点都有d个儿子，在优先队列太大无法装进主存，就可以使用d堆，相当于b树。
## 左式堆
堆难以实现find和**合并**(merge)，故使用左式堆。左式堆与二叉堆唯一的区别是不平衡，其左树深于右树。
### 性质
定义**零路径长npl(X)**,表示从X到一个不含有两个儿子的节点的最短路径长。
单节点的npl＝0；无节点的npl＝－1。
### 操作
其他操作与二叉树一致，这里讨论合并。
两个左式堆的合并，首先将A堆的右子树插入B堆（B堆的根节点大于A堆），再作为右子树插入A堆，最后为满足左式堆的性质，可能交换两个子树。
## 斜堆
斜堆与左式堆的差别在于斜堆不对左右子树的深度做要求。
斜堆的主要操作也是合并
### 合并
## 二项队列（没讲）
二项队列的插入花费常数时间，其他操作花费`O(logN)`
### 二项队列的构建
二项队列由许多个二项树组成，分别由 $B_i$ 表示，其中，i也表示每个树的高度，i从0开始计。这些项数的集合称为**森林**。如下图所示：

每个二项树的节点数为 $2^i$ ,每个二项树的每个高度的节点数为 $C_{i}^{k},0<=k<=i$ 。
### 二项队列操作
#### 插入
二项队列的插入由合成大西瓜构成。先得到 $B_0$ （高度为0），随后插入一值得到 $B_1$ （高度为1）；再插入两个值，现在有两个 $B_1$ ，因此可以合成 $B_2$ ，诸如此类，如下图所示

其中，大小的比较仍然存在，相同高度的树的合并由下给出
#### 合并
 当两个树的高度相同时，二者就可以合并。合并时，取较小的根节点作为新的根节点，另一个树作为子节点插入新的根节点。合并是连锁的，可以（1+1）+2＝3。如下图：

#### 删除最小值
先寻找二项队列中最小的根，将对应的二项树从森林中删除，得到新的二项队列 $H''$ ,然后，将此前的二项树的根节点删除，得到新的二项队列 $H''$ ，我们对两个二项队列合并即可。
### 二项队列实现
# 排序
## 插入排序
维护一个指针，用来遍历排序的数组，指针每移动一次，就把当前位置的数字一次向前比较，直到插入一个合适的位置，此方法保证此前的数据都是有效的。
### 实现

### 分析
运行时间上界$O(N^2)$，下界$O(N)$，平均$O(N^2)$。
## 冒泡排序
双重循环，每次比较相邻的两值，若最小的循环内未发生交换，则排序成功
### 分析
运行时间上界$O(N^2)$，下界$O(N)$，平均$O(N^2)$。
## 选择排序
遍历序列，找到最小值，放置在队首，再循环的找剩下队列的最小值
### 分析
运行时间$O(N^2)$。
## 希尔排序
希尔排序使用一个增量序列$h_k$，每次排序增量序列发生改变，保证$a[i]<=a[i+h_k]$，由此逐渐使$h_k$递减，直到完成排序
### 实现
### 分析
运行时间上界$O(N^2)$（使用希尔增量）；$O(N^{3/2})$（使用Hibbard增量序列。
## 堆排序
对给出的序列构建**MAX堆**（大小选取与二叉堆相反），每次执行deletedMax，并把最大值放置在数组中因为下滤而空出的那一位中。由此得到的是由小到大的已排序的数组。
### 实现
### 分析
运行时间上界$2NlogN-O(N)$，平均$2NlogN-O(NloglogN)$。
## 归并排序
归并排序递归的将序列分为前后一半，排序好后合并两个子序列，直到递归到最大的序列。
### 实现
### 分析
运行时间上界$O(NlogN)$。
## 快速排序
包含4步：
1. 若S中的元素个数为0或1，则直接返回
2. 取S中的任意元素v，称之为枢纽元
3. 将S中小于等于v的和大于等于v的分为两个子集
4. 返回对这两个子集的快速排序。
整体上看，我们只在分集合时进行了排序，且排序由小到大，每次得到枢纽元，以便于合并序列
### 选取枢纽元

